#####   Введение в множественное наследование и супер ()   #####

'''
Краткий обзор наследования.
По мере развития ваших проектов вы неизбежно захотите использовать классы и при этом применять принцип DRY (Don't repeat yourself). Наследование классов - это способ создать класс на основе другого класса, чтобы соблюдать принцип DRY.

Так что же такое наследование классов? Подобно генетике, дочерний класс может «наследовать» атрибуты и методы от родителя. Давайте рассмотрим пример кода. В приведенном ниже блоке кода мы продемонстрируем наследование с помощью Child класса, унаследованного от Parent класса.
'''

# class Parent:
#     def __init__(self):
#         self.parent_attribute = 'I am a parent'

#     def parent_method(self):
#         print('Back in my day...')


# # Создаем дочерний класс, который наследуется от родительского
# class Child(Parent):
#     def __init__(self):
#         Parent.__init__(self)
#         self.child_attribute = 'I am a child'


# # Создаем экземпляр от дочернего класса
# child = Child()

# # Печатаем атрибуты и методы дочернего класса
# print(child.child_attribute)
# print(child.parent_attribute)
# child.parent_method()

# # Вывод
# # I am a child
# # I am a parent
# # Back in my day...

'''
Мы видим, что Child класс «унаследовал» атрибуты и методы от Parent класса. Без какой-либо работы с нашей стороны, Parent.parent_method является частью дочернего класса. Чтобы получить преимущества метода Parent.__init__(), нам нужно было явно вызвать метод и передать self. Это потому, что когда мы добавили метод __init__ в Child, мы переписали наследуемое __init__.

Введение в super().
В простейшем случае функцию super можно использовать для замены явного вызова Parent.__init__(self). Наш вводный пример выше можно переписать, используя super как показано ниже. Обратите внимание, что приведенный ниже блок кода написан на Python 3, более ранние версии используют немного другой синтаксис.
'''

# class Parent:
#     def __init__(self):
#         self.parent_attribute = 'I am a parent'

#     def parent_method(self):
#         print('Back in my day...')


# # Создаем дочерний класс, который наследуется от родительского
# class Child(Parent):
#     def __init__(self):
#         super().__init__()
#         self.child_attribute = 'I am a child'


# # Создаем экземпляр от дочернего класса
# child = Child()

# # Печатаем атрибуты и методы дочернего класса
# print(child.child_attribute)
# print(child.parent_attribute)
# child.parent_method()

# # Вывод
# # I am a child
# # I am a parent
# # Back in my day...

'''
Если честно, то super в этом случае дает нам мало преимущества, если вообще имеет. Ниже приведены некоторые плюсы и минусы использования super в случаях единственного наследования.

Минусы.
Можно утверждать, что использование super здесь делает код менее явным. Делая код менее явным, вы нарушаете Дзен Python, который гласит: "явное лучше, чем неявное."

Плюсы.
Существует аргумент в пользу ремонтопригодности, который может быть сделан для super даже для одиночного наследования. Если по какой-либо причине ваш дочерний класс меняет свой шаблон наследования (т.е. изменяется родительский класс или происходит переход к множественному наследованию), то нет необходимости искать и заменять все устаревшие ссылки ParentClass.method_name().

super и множественное наследование.
Прежде всего, что такое множественное наследование? До сих пор пример кода охватывал один дочерний класс, наследуемый от одного родительского класса. При множественном наследовании существует более одного родительского класса. Дочерний класс может наследовать от 2, 3, 10 и т.д. родительских классов.

Вот где преимущества super становятся более очевидными. Если вы собираетесь использовать множественное наследование, используйте super.

Множественное наследование без super.
Давайте рассмотрим пример множественного наследования, которое избегает модификации любых родительских методов и, в свою очередь, избегает super.
'''

# class B:
#     def b(self):
#         print('b')


# class C:
#     def c(self):
#         print('c')


# class D(B, C):
#     def d(self):
#         print('d')


# d = D()
# d.b()
# d.c()
# d.d()

# # Вывод
# # b
# # c
# # d

'''
Порядок разрешения методов (Multiple-resolution order).
Этот вывод не слишком удивителен, учитывая концепцию множественного наследования. D унаследовал методы x и z родительских классов.

А что если оба класса, и B, и C имеют метод с одинаковым именем? Именно здесь в игру вступает понятие, называемое «порядок разрешения методов» или MRO. MRO дочернего класса - это то, что решает, где Python будет искать данный метод, и какой метод будет вызываться при возникновении конфликта.

Давайте посмотрим на пример.
'''

# class B:
#     def x(self):
#         print('x: B')


# class C:
#     def x(self):
#         print('x: C')


# class D(B, C):
#     pass


# d = D()
# d.x()
# print(D.mro())

# # Вывод
# # x: B
# # [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class 'object'>]

'''
Когда мы вызываем унаследованный метод x, мы видим только выходные данные, унаследованные от B. Мы можем увидеть MRO нашего класса D, вызвав метод класса mro. Из вывода D.mro() мы узнаем следующее: наша программа будет пытаться вызывать методы D по умолчанию, а затем прибегнуть к B, затем C, наконец object. Если он не найден ни в одном из этих мест, то мы получим ошибку, что у D нет метода, который мы просили.

Стоит отметить, что по умолчанию каждый класс наследуется от object и он находится в конце каждого MRO.

Множественное наследование, super и проблема ромба (Diamond problem).
Ниже приведен пример использования super для обработки MRO init так, чтобы это было выгодно. В этом примере мы создаем серию классов обработки текста и объединяем их функциональность в другом классе с множественным наследованием. 

На самом деле это пример «проблемы ромба» множественного наследования. Его название, конечно же, основано на форме его иллюстрации и на том, что это довольно запутанная проблема.
'''

# class Tokenizer:
#     """Tokenize text"""
#     def __init__(self, text):
#         print('Start Tokenizer.__init__()')
#         self.tokens = text.split()
#         print('End Tokenizer.__init__()')


# class WordCounter(Tokenizer):
#     """Count words in text"""
#     def __init__(self, text):
#         print('Start WordCounter.__init__()')
#         super().__init__(text)
#         self.word_count = len(self.tokens)
#         print('End WordCounter.__init__()')


# class Vocabulary(Tokenizer):
#     """Find unique words in text"""
#     def __init__(self, text):
#         print('Start init Vocabulary.__init__()')
#         super().__init__(text)
#         self.vocab = set(self.tokens)
#         print('End init Vocabulary.__init__()')


# class TextDescriber(WordCounter, Vocabulary):
#     """Describe text with multiple metrics"""
#     def __init__(self, text):
#         print('Start init TextDescriber.__init__()')
#         super().__init__(text)
#         print('End init TextDescriber.__init__()')


# td = TextDescriber('row row row your boat')
# print('--------')
# print(td.tokens)
# print(td.vocab)
# print(td.word_count)

# # Вывод
# # Start init TextDescriber.__init__()
# # Start WordCounter.__init__()
# # Start init Vocabulary.__init__()
# # Start Tokenizer.__init__()
# # End Tokenizer.__init__()
# # End init Vocabulary.__init__()
# # End WordCounter.__init__()
# # End init TextDescriber.__init__()
# # --------
# # ['row', 'row', 'row', 'your', 'boat']
# # {'boat', 'your', 'row'}
# # 5

'''
Прежде всего, мы видим, что класс TextDescriber унаследовал все атрибуты семейного древа класса. Благодаря множественному наследованию мы можем «объединить» функциональность нескольких классов.

Давайте теперь обсудим распечатки, полученные из методов init класса:

Каждый __init__метод вызывался один раз и только один раз.
Класс TextDescriber наследуется от 2 -х классов , которые наследуются от Tokenizer. Почему Tokenizer.__init__не вызвался дважды?

Если бы мы заменили все наши вызовы super старым способом, мы бы получили 2 вызова Tokenizer.__init__. Вызывы super «думают» о нашем шаблоне немного больше и пропускают дополнительные поездки A.

Каждый __init__метод был запущен до того, как были закончены другие.
Стоит отметить в случае, если вы пытаетесь установить атрибут, который имеет конфликт именования с другим родительским классом, атрибут будет перезаписан, и это может стать очень запутанным.

В нашем случае мы избежали конфликтов имен с унаследованными атрибутами, поэтому все работает как положено.

Повторим еще раз: проблема ромба может быстро усложниться и привести к неожиданным результатам. В большинстве случаев в программировании лучше избегать сложных конструкций.

Что мы узнали
Мы узнали о функции super и о том, как ее можно использовать для замены ParentName.method при одиночном наследовании. Это более приемлемая практика.
Мы узнали о множественном наследовании и о том, как мы можем передать функциональность нескольких родительских классов одному дочернему классу.
Мы узнали о порядоке разрешения методов и о том, как он решает, что происходит при множественном наследовании, когда существует конфликт имен между родительскими методами.
Мы узнали о проблеме ромба и увидели пример того, как использование super ориентирует ромб. '''